concentrate on understanding where rule is defined in existing system
add main method and run application
write acceptance test for existing behaviour, ensures that using latest working code base
code not written with testing in mind, can't wire up acceptance tests easily/correctly
needs refactoring in order to be able to sense values, inject customers/calls and remove dependency on current time (brittle tests)
create seam/inject it, but don't want to do that without refactoring code before writing test,
so change it so the code always uses a fixed time, write unit tests for safety net, refactor time out and use mock for tests
acceptance tests done against real database, need to use DI and mock implementation so get predictable tests
verify requirements with user, bridge communication gap using Cucumber
once verified existing code is actually working, can almost 'discard' those tests and create acceptance tests for new behaviour
when is the deadline for this new regulation? assumption that is at cw submission deadline
implement new rule, make sure this requirement is met first, don't throw away existing code!
then concentrate on refactoring design for extensibility under safety of 

Acceptance Tests
	gather requirements from user
	fit/cucumber tests
TDD
	introduce seams, 
	unit tests, (EMMA code coverage)
Object-Oriented
	objects have roles
	tell, don't ask
	mock objects (mockito)
	Ports and Adapters
DSL?
	domain driven
	fluent interface
	guide the API user
layering (structure 101)
	interfaces for abstractions
	abstract server/client
	interface segregation principle
dependency injection (google guice)
	handling singletons
	frameworks?
developing under pressure
	iterative development
	requirements analysis and design
	develop a feature at a time (vertical slice)
	extend with extra functionality (horizontal slice)
deployment/release
	continuous integration (jenkins)
	continuous deployment after implementing basic requirements
	blue/green, canary, split test, (production parallel)

jbehave
jenkins/cucumber on micro EC2 instance
build and dependency management using buildr/gradle
build management using or gant
issue tracking tools e.g. JIRA
adding a UI or designing bills e.g. balsamiq mockups

different way of showing the bill/receipt
rules could change in the future
negative time?? use JodaTime


off-peak charges (pence/minute):
standard: 0.12
business: 0.18
leisure: 0.06

peak charges (pence/minute):
standard: 0.30
business: 0.18
leisure: 0.48

bill shows how portion of call was charged
from 7th hour onwards changes tariff
still using existing peak off-peak function
order calls by start time then duration on the bill!
acceptance tests across call plans use the same call times (control/fairness/clearness)
query table for call costs, split per customer

wrote a nearly end-to-end FitNesse test
had to redirect System.out!
fixed the times!
failed on jenkins due to newline char being different
gets tariff for each customer inside call loop, inefficient, call it from outside
injected billgenerator
created new test using mocking of billgenerator, customerdb, tarifflib
still use callinit and call complete, still with fixed times
but needed to add equals and hashcode to lineitem for verifying billgen send
broke up createBillForCustomer into a number of methods such as getCallsFor(customer), calculateCostOfEachCall, calculateTotalBill
introduce CallLogger with getCallsFor()
changed so that call time could be injected into call event
separate out BillCalculator
Customer factory method with tinytypes for firstname, lastname, number


add DSL for CallLogger